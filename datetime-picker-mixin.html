<link rel="import" href="datetime-mixin.html">
<link rel="import" href="datetime-shared-style.html">

<script>
  /**
   * Mixin to extend an element for picking date or time to locale formating and hiding certain datetime-properties
   *
   * @appliesMixin DatetimeMixin
   *
   * @mixinFunction
   * @polymer
   */
  const DatetimePickerMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends DatetimeMixin(superClass) { // eslint-disable-line no-undef

      static get properties() {
        return {

          /**
           * The current locale
           */
          locale: {
            type: String,
            value: window.navigator.language,
            observer: '_localeChanged'
          },

          /**
           * locale representation of 'AM'
           */
          _am: {
            type: String
          },

          /**
           * locale representation of 'PM'
           */
          _pm: {
            type: String
          },

          /**
           * Separator for local date values (date-string is still in ISO-Format)
           * @type {string}
           */
          _localDateSeparator: {
            type: String,
            value: '-'
          },

          /**
           * Separator for local time values (time-string is still in ISO-Format)
           * @type {string}
           */
          _localTimeSeparator: {
            type: String,
            value: ':'
          },

          /**
           * Separator for local decimal values
           * @type {string}
           */
          _localDecimalSeparator: {
            type: String,
            value: '.'
          },

          /**
           * clamp datetime to a property
           * possible values: 'month', 'day', 'hours', 'minutes', 'seconds', 'milliseconds'
           */
          clamp: {
            type: String
          },

          /**
           * order of date-parts
           */
          _orderDate: {
            type: Object,
            value: function() {
              return {
                year: 1,
                separatorYearMonth: 2,
                month: 3,
                separatorMonthDay: 4,
                day: 5
              };
            }
          },

          /**
           * The year of the view
           */
          _viewYear: {
            type: Number,
            notify: true
          },

          /**
           * The month of the view
           */
          _viewMonth: {
            type: Number,
            notify: true
          },

          /**
           * The day of the view
           */
          _viewDay: {
            type: Number,
            notify: true
          },

          /**
           * The hours-12 of the view
           */
          _viewHours: {
            type: Number,
            notify: true,
            observer: '_viewHoursChanged'
          },

          /**
           * The hours of the view
           */
          _viewHours12: {
            type: Number,
            notify: true,
            observer: '_viewHours12Changed'
          },

          /**
           * The hours of the view
           */
          _isAm: {
            type: Boolean,
            observer: '__isAmChanged'
          },

          /**
           * The minutes of the view
           */
          _viewMinutes: {
            type: Number,
            notify: true
          },

          /**
           * The seconds of the view
           */
          _viewSeconds: {
            type: Number,
            notify: true
          },

          /**
           * The milliseconds of the view
           */
          _viewMilliseconds: {
            type: Number,
            notify: true
          },

          /**
           * Set to true to activate mediation for confirming the input.
           */
          mediated: {
            type: Boolean,
            value: false
          }
        }
      }

      static get template() {
        return `
          ${this.styleTemplate}
        `
      }

      static get styleTemplate() {
        return `
          <style include="${this.customStyleToInclude}">
            ${this.customStyleContent}
          </style>
        `;
      }

      static get customStyleToInclude() {
        return 'datetime-shared-style';
      }

      static get customStyleContent() {
        return `
          ${super.customStyleToInclude || ''}
          number-input {
            --number-input: {
              @apply --datetime-input;
            };
            --number-input-focus: {
              @apply --datetime-focus;
            };
          }
        `;
      }

      /**
       * template for control buttons
       * @type {string}
       */
      static get _buttonTemplate() {
        return `
          ${super._buttonTemplate || ''}
          <svg class="icon button now" hidden$="[[!opened]]" viewBox="0 0 24 24" on-click="now"><g><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></g></svg>
        `;
      }

      static get observers() {
        return [
          '_computeViewDatetime(year, month, day, hours, minutes, seconds, milliseconds)',
          '_viewDaytimeChanged(_viewYear, _viewMonth, _viewDay, _viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.value === undefined) {
          this.value = +(new Date());
        }
      }

      _computeViewDatetime(year, month, day, hours, minutes, seconds, milliseconds) {

        let d = new Date(+(year || 1970), +(month || 1) - 1, +(day || 1), +(hours || 0), +(minutes || 0), +(seconds || 0), +(milliseconds || 0));

        if (!isNaN(+d)) {
          let c;
          if (this._checkMin(d) === false) {
            c = new Date(this.min);
          } else if (this._checkMax(d) === false) {
            c = new Date(this.max);
          }

          if (c) {
            year = c.getFullYear(); month = c.getMonth() + 1; day = c.getDate(); hours = c.getHours(); minutes = c.getMinutes(); seconds = c.getSeconds(); milliseconds = c.getMilliseconds();
          } else {
            year = d.getFullYear(); month = d.getMonth() + 1; day = d.getDate(); hours = d.getHours(); minutes = d.getMinutes(); seconds = d.getSeconds(); milliseconds = d.getMilliseconds();
          }

          switch (this.clamp) {
            case 'year':
            case 'month':
              month = 1; // falls through
            case 'day':
              day = 1; // falls through
            case 'hours':
              hours = 0; // falls through
            case 'minutes':
              minutes = 0; // falls through
            case 'seconds':
              seconds = 0; // falls through
            case 'milliseconds':
              milliseconds = 0;
          }

          const newDate = new Date(year, month - 1, day, hours, minutes, seconds, milliseconds);

          if (+newDate !== +d) {
            if (!this.mediated) {
              this.value = +newDate;
            }
            return;
          }

          this.setProperties({
            _viewYear: year,
            _viewMonth: month,
            _viewDay: day,
            _viewHours: hours,
            _viewMinutes: minutes,
            _viewSeconds: seconds,
            _viewMilliseconds: milliseconds,
          });

          if (super._computeViewDatetime) {
            super._computeViewDatetime(year, month, day, hours, minutes, seconds, milliseconds);
          }
        }
      }

      _viewDaytimeChanged(_viewYear, _viewMonth, _viewDay, _viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds) {
        let d = new Date(+(_viewYear || 1970), +(_viewMonth || 1) - 1, +(_viewDay || 1), +(_viewHours || 0), +(_viewMinutes || 0), +(_viewSeconds || 0), +(_viewMilliseconds || 0));

        if (!isNaN(+d)) {
          let c;
          if (this._checkMin(d) === false) {
            c = new Date(this.min);
          } else if (this._checkMax(d) === false) {
            c = new Date(this.max);
          }

          if (c) {
            _viewYear = c.getFullYear(); _viewMonth = c.getMonth() + 1; _viewDay = c.getDate(); _viewHours = c.getHours(); _viewMinutes = c.getMinutes(); _viewSeconds = c.getSeconds(); _viewMilliseconds = c.getMilliseconds();
          } else {
            _viewYear = d.getFullYear(); _viewMonth = d.getMonth() + 1; _viewDay = d.getDate(); _viewHours = d.getHours(); _viewMinutes = d.getMinutes(); _viewSeconds = d.getSeconds(); _viewMilliseconds = d.getMilliseconds();
          }

          switch (this.clamp) {
            case 'year':
            case 'month':
              _viewMonth = 1; // falls through
            case 'day':
              _viewDay = 1; // falls through
            case 'hours':
              _viewHours = 0; // falls through
            case 'minutes':
              _viewMinutes = 0; // falls through
            case 'seconds':
              _viewSeconds = 0; // falls through
            case 'milliseconds':
              _viewMilliseconds = 0;
          }

          const newDate = new Date(_viewYear, _viewMonth - 1, _viewDay, _viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds);

          if (+newDate !== +d) {
            this._computeViewDatetime(_viewYear, _viewMonth, _viewDay, _viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds);
            return;
          }

          if (!this.mediated) {
            const date = this._toDate(new Date(_viewYear, _viewMonth - 1, _viewDay));
            const time = this._toTime(new Date(_viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds));
            this.setProperties({
              year: _viewYear,
              month: _viewMonth,
              day: _viewDay,
              hours: _viewHours,
              minutes: _viewMinutes,
              seconds: _viewSeconds,
              milliseconds: _viewMilliseconds,
              date: date,
              time: time
            });
          }
          if (super._viewDaytimeChanged) {
            super._viewDaytimeChanged(_viewYear, _viewMonth, _viewDay, _viewHours, _viewMinutes, _viewSeconds, _viewMilliseconds);
          }
        }
      }

      _viewHoursChanged(_viewHours) {
        console.log(_viewHours);
        this._isAm = _viewHours < 12;
        this._viewHours12 = (_viewHours === 0) ? 12 : (_viewHours > 12 ? _viewHours - 12 : _viewHours);
      }

      _viewHours12Changed(_viewHours12) {
        this._viewHours = (_viewHours12 === 12) ? (this._isAm ? 0 : 12) : (this._isAm ? _viewHours12 : _viewHours12 + 12);
      }

      __isAmChanged(_isAm) {
        if (_isAm === undefined) return;

        if (this._viewHours >= 12 && _isAm === true) {
          this._viewHours -= 12;
        } else if (this._viewHours <= 12 && _isAm === false) {
          this._viewHours += 12;
        }
      }

      _localeChanged(locale) {
        if (!locale) {
          this.locale = window.navigator.language;
          return;
        }
        // test locale (currently just for Latin letters and Western Arabic/European numerals)
        locale += '-u-nu-latn-ca-iso8601';

        let date = new Date(1970, 10, 15, 6, 24, 25);

        // check date
        const dateString = date.toLocaleDateString( locale, { year: 'numeric', month: 'numeric', day: 'numeric' });

        // date separator
        const dateSeparator = dateString.split(/\d|\s/g).filter(s => { return s !== ''; })[0];

        // order of the date parts
        let parts = dateString.split(/\D/);
        parts.splice(1, 0, '');
        parts.splice(3, 0, '');

        let order = {};
        order.year = parts.indexOf('1970') + 1;
        order.month = parts.indexOf('11') + 1;
        order.day = parts.indexOf('15') + 1;
        order.separatorYearMonth = order.year > order.month ? order.year - 1 : order.month - 1;
        order.separatorMonthDay = order.month > order.day ? order.month - 1 : order.day - 1;

        // check time
        let timeString = date.toLocaleTimeString( locale, { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: false });

        // time separator
        const timeSeparator = timeString.split(/\d/g).filter(s => { return s !== ''; }).pop();

        // am-string
        timeString = date.toLocaleTimeString( locale, { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true });
        const am = timeString.split(/\d/g).filter(s => { return /[^\s:\|\/,;\.]{1}/.test(s); }).pop();

        // pm-string
        date = new Date(1970, 10, 15, 18, 24, 25);
        timeString = date.toLocaleTimeString( locale, { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true });
        const pm = timeString.split(/\d/g).filter(s => { return /[^\s:\|\/,;\.]{1}/.test(s); }).pop();

        // decimal separator
        let decimalSeparator = new Intl.NumberFormat(locale).format(1.2).split(/\d/g).filter(s => { return s !== ''; }).pop();

        this.setProperties({
          _orderDate: order,
          _localDateSeparator: dateSeparator,
          _localTimeSeparator: timeSeparator,
          _localDecimalSeparator: decimalSeparator,
          _am: am,
          _pm: pm
        });
      }

      _checkKeycode(e) {
        if (!e) {
          return;
        }
        if (e.keyCode === 13 || e.keyCode === 32) { // space || enter
          this.confirm();
          return;
        }
        if (super._checkKeycode) {
          super._checkKeycode(e);
        }
      }

      /**
       * confirms the input
       * @param  {[type]} e Event
       */
      confirm() {
        if (super.confirm) {
          super.confirm();
        } else {
          this._computeValue(new Date(this._viewYear, this._viewMonth - 1, this._viewDay, this._viewHours, this._viewMinutes, this._viewSeconds, this._viewMilliseconds));
        }
        if (this.close) {
          this.close();
        }
      }

      /**
       * cancels the input
       * @param  {[type]} e Event
       */
      cancel() {
        this._computeValue(this.date, this.time);
        if (this.close) {
          this.close();
        }
      }

    }
  }
</script>
